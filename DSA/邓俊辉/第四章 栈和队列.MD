# 栈和队列

栈与队列是两种更基本，但是更常用的数据结构，同样是线性序列结构。相对于一般的序列结构，栈与队列的区别是他们的数据操作范围仅限于逻辑上的特定某端。然而，得益于其简洁性与规范性，它们既成为构建更复杂、更高级数据结构的基础，同时也是算法设计的基本出发点，甚至常常作为标准配置的基本数据结构以硬件形式直接实现。

    在信息处理领域，无论PostScript或者Java，其实时运行环境都是基于栈结构的虚拟机；网络浏览器多会将用户最近访问过的地址组织为一个栈从而实现前进后退；类似地，主流的文本编辑器也大都支持编辑操作的历史记录功能，用户的编辑操作被依次记录在一个栈中。

    在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的CPU时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。

栈和队列可视作向量与列表的特例，因此C++的继承与封装机制在此可以大显身手。本章的重点将不再拘泥于对数据结构
内部实现机制的展示，并转而更多地从其外部特性出发，结合若干典型的实际问题介绍栈与队列的具体应用。

## 栈

### ADT接口

操作接口       功 能
size()      报告栈的规模
empty()     判断栈是否为空
push(e)     将e插至栈顶
pop()       删除栈顶对象
top()       引用栈顶对象

#### 入栈和出栈

栈（stack）是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故也可定义首、末元素。不过，尽管栈结构也支持对象的插入和删除操作，但其操作的范围仅限于栈的某一特定端。也就是说，若约定新的元素只能从某一端插入其中，则反过来也只能从这一端删除已有的元素。禁止操作的另一端，称作盲端。栈中可操作的一端更多地称作栈顶（stack top），而另一无法直接操作的盲端则更多地称作栈底（stack bottom）。

除了引用栈顶的top()等操作外，最常用的插入与删除操作分别称作入栈（push）和出栈（pop）。
分别用尖括号、方括号示意栈顶、栈底，这也是本小节将统一采用的约定。


#### 后进先出（LIFO）

栈中元素接受操作的次序必然始终遵循所谓“后进先出”（last-in-first-out, LIFO）的规律：更晚（早）出栈的元素，应为更早（晚）入栈者；反之，更晚（早）入栈者应更早（晚）出栈。

### Stack模板类

既然栈可视作序列的特例，故只要将栈作为向量的派生类，即可利用C++的继承机制，基于向量模板类实现栈结构。当然，这里需要按照栈的习惯，对各接口重新命名。

既然栈操作都限制于向量的末端，参与操作的元素没有任何后继，以上栈接口的时间复杂度均为常数。
套用以上思路，也可直接基于List模板类派生出Stack类。

## 栈与递归

递归算法所需的空间量，主要决定于最大递归深度。操作系统具体是如何实现函数（递归）调用的？如何记录调用与被调用函数（递归）实例之间的关系？如何实现函数（递归）调用的返回？又是如何维护同时活跃的所有函数（递归）实例的？所有这些问题的答案，都可归结于栈。

### 函数调用栈

在Windows等大部分操作系统中，每个运行中的二进制程序都配有一个调用栈（call stack）或执行栈（execution stack）。借助调用栈可以跟踪属于同一程序的所有函数，记录它们之间的相互调用关系，并保证在每一调用实例执行完毕之后，可以准确地返回。

#### 函数调用

调用栈的基本单位是帧（frame）。每次发生函数调用时会产生一个帧，帧里面保存了跳转之前的地址，也就是被调用函数用来返回的地址，以及原函数的局部变量，传入调用函数的参数等，然后将帧入栈。若该函数返回之前又发生了调用，进行相同的处理。直到函数一个个完成，对应的帧一个个弹出。运行控制权将被交还给返回到的上层调用函数，并按照该帧中记录的返回地址确定在二进制程序中继续执行的位置。

在任一时刻，调用栈中的各帧，依次对应于那些尚未返回的调用实例，亦即当时的活跃函数实例（active function instance）。特别地，位于栈底的那帧必然对应于入口主函数main()，若它从调用栈中弹出，则意味着整个程序的运行结束，此后控制权将交还给操作系统。仿照递归跟踪法，程序执行过程出现过的函数实例及其调用关系，也可构成一棵树，称作该程序的运行树。任一时刻的所有活跃函数实例，在调用栈中自底到顶，对应于运行树中从根节点到最新活跃函数实例的一条调用路径。此外，调用栈中各帧还需存放其它内容。比如，因各帧规模不一，它们还需记录前一帧的起始地址，以保证其出栈之后前一帧能正确地恢复。

#### 递归

作为函数调用的特殊形式，递归也可借助上述调用栈得以实现。比如对应于一个函数funcB()的自我调用，也会新压入一帧。可见，同一函数可能同时拥有多个实例，并在调用栈中各自占有一帧。这些帧的结构完全相同，但其中同名的参数或变量，都是独立的副本。

### 避免递归

在进行递归调用时，系统在后台隐式地维护调用栈的过程中，难以区分哪些参数和变量是对计算过程有实质作用的，更无法以通用的方式对它们进行优化，因此不得不将描述调用现场的所有参数和变量悉数入栈。再加上每一帧都必须保存的执行返回地址以及前一帧起始位置，往往导致程序的空间效率不高甚至极低；同时，隐式的入栈和出栈操作也会令实际的运行时间增加不少。

在追求更高效率的场合，应尽可能地避免递归，尤其是过度的递归。此前已经介绍过相应的方法和技巧。例如将尾递归转换为等效的迭代形式；中采用动态规划策略，将Fibonacci数算法中的二分递归改为线性递归，直至完全消除递归。

既然递归本身就是操作系统隐式地维护一个调用栈而实现的，自然也可以通过显式地模拟调用栈的运转过程，实现等效的算法功能。采用这一方式，程序员可以精细地裁剪栈中各帧的内容，从而尽可能降低空间复杂度的常系数。尽管算法原递归版本的高度概括性和简洁性将大打折扣，但毕竟在空间效率方面可以获得足够的补偿。

## 栈的典型应用

### 逆序输出

- 问题特征

在栈所擅长解决的典型问题中，有一类具有以下共同特征：
首先，虽有明确的算法，但其解答却以线性序列的形式给出；其次，无论是递归还是迭代实现，该序列都是依逆序计算输出的；最后，输入和输出规模不确定，难以事先确定盛放输出数据的容器大小。因其特有的“后进先出”特性及其在容量方面的自适应性，使用栈来解决此类问题可谓恰到好处。

#### 进制转换

- 问题

任给十进制整数n，将其转换为r进制的表示形式。

- 分析

比如r=8时，12345(10) = 30071(8)，一般的，r进制转10进制的方法是，n=（dm…d2d1d0）（r）=dm*r^m+…+d2*r^2+d1*r^1+d0*r^0。反过来，10进制转r进制，k（10）%r，第一个与出来的数就是r进制的最低位，余数继续和r相于，获得r进制的下一位，直到余数为0。可见，该算法的输出的确为一个长度不定的逆序线性序列。

- 实现逻辑

尽管新进制下的各数位须按由低到高次序逐位算出，但只要引入一个栈并将算得的数位依次入栈，则在计算结束后只需通过反复的出栈操作即可由高到低地将其顺序输出。将一个十进制数n于新的进制r相于，结果入栈，余数进入递归，重复以上操作。最后栈中存放的就是转换后的r进制数的由低到高位。然后依次出栈即可。

- 迭代实现

进制转换算法中无论是n还是数组还是动态的余数都只需要保存一份，但是由于递归函数的特定，实际上每次递归都会保存一份。只有避免递归才可以避免这个问题，让空间消耗降至O(1)。

其实递归操作中也只不过是让余数一直更新，这一步拿出来操作，便不再需要递归。

- 代码

/DSA/convert.cpp/convertA()（递归版）
/DSA/convert.cpp/convertB()（迭代版）

### 递归嵌套

- 问题特征

具有自相似性的问题多可嵌套地递归描述，但因分支位置和嵌套深度并不固定，其递归算法的复杂度不易控制。栈结构及其操作天然地具有递归嵌套性，故可用以高效地解决这类问题。

#### 栈混洗

栈混洗应该是对于栈的操作的一种模式的抽象。

- 定义

假设有三个栈A，S，B，其中A中有n个元素，S，B中为空。此时要求只允许有两种操作：S.push( A.pop() )弹出栈A的顶元素并随即压入栈S中，或B.push( S.pop() ))弹出S的顶元素并随即压入栈B中。在“实施出栈操作时栈不得为空”这一唯一条件之下，则在经过这两类操作各n次之后，栈A和S有可能均为空，原A中的元素均已转入栈B。此时B栈构成的序列乘坐原序列的一个栈混洗。

- 分析

可以意识到其实S栈就是一个中介，本意是模拟从一个输出顺序不可以改变的序列A通过一个栈，在受到栈的特性的限制下，可能的输出序列B。B需要的输出限制就要具体判断力，不一定也非要顺序输出。基于此可以分析到，**对于长度为n的输入序列，每一栈混洗都对应于由栈S的n次push和n次pop构成的某一合法操作序列**，反之，由n次push和n次pop构成的任何操作序列，只要满足“任一前缀中的push不少于pop”这一限制，则该序列也必然对应于某个栈混洗。

##### 括号匹配

在源程序代码编译检查，和数学式计算中，对括号匹配的检查十分必要。即判断其中的括号是否在嵌套的意义下完全匹配（简称匹配）。

- 实现逻辑

设想一个表达式S=S0+S1+S2+S3，Sn是S内部的小表达式，其中S0和S3中没有括号，那么S匹配<=>S1匹配且S2匹配。因此可以采用分治策略，将大表达式递归的分解成小表达式分别判断是否匹配。

首先排除掉向S0S3这种不含符号的前后缀，只需要从前和从后开始依次扫描字符，遇到'（'和'）'之前的符号直接截掉即可。并且清除后的表达式，如果首字符非左括号或尾字符非右括号，表示匹配失败。

然后就是最重要的分解任务，先引入一个左右括号数量差的计数器crc，将表达式从左往右依次扫描，遇到左括号crc+1，右括号crc-1。当crc=0且没越界时，且分出两个符号数量基本匹配的子表达式，等待进一步分解，并且如果扫描越界表示匹配失败。

每次先剔除前后缀，判断首尾括号，然后分解子表达式，将子表达式剔除首尾括号递归重复以上操作，递归基是剔除前后缀后首指针越过尾指针。

- 复杂度

在最坏情况下divide()需要线性时间，且递归深度为O(n)，故以上算法共需O(n2)时间。此外，该方法也难以处理含有多种括号的表达式，故有必要进一步优化。

- 迭代实现

实际上，只要将一个括号序列看作一个栈，将push、pop操作分别与左、右括号相对应，则长度为n的栈混洗，必然与由n对括号组成的合法表达式彼此对应。比如，栈混洗[ 3, 2, 4, 1 >，对应S栈的操作序列是：push，push，push，pop，pop，push，pop，pop。对应于表达式"( ( ( ) ) ( ) )"。按照这一理解，借助栈结构，只需扫描一趟表达式，即可在线性时间内，判定其中的括号是否匹配。

- 实现逻辑

一个合法的括号序列总是成对出现的，假如从内往外一对一对的消除每对相邻括号，合法序列总是可以正好的消除全部括号。用栈来实现这个效果就是：自左向右逐个考查各字符，忽略所有非括号字符。凡遇到左括号，无论属于哪类均统一压入栈S中。若遇右括号，则弹出栈顶的左括号并与之比对。若二者属于同类，则继续检查下一字符。否则，即可断定表达式不匹配。当然，栈S提前变空或者表达式扫描过后栈S非空，也意味着不匹配。

- 代码

/DSA/paren.cpp/trim()(剔除前后缀)
/DSA/paren.cpp/divide()（切分子表达式）
/DSA/paren.cpp/paren()（递归检查括号匹配）
/DSA/paren.cpp/parenStack()（通过栈检查括号匹配）

### 延迟缓冲

### 逆波兰表达式

## 试探回溯法

## 队列

## 队列应用
