# 栈和队列

栈与队列是两种更基本，但是更常用的数据结构，同样是线性序列结构。相对于一般的序列结构，栈与队列的区别是他们的数据操作范围仅限于逻辑上的特定某端。然而，得益于其简洁性与规范性，它们既成为构建更复杂、更高级数据结构的基础，同时也是算法设计的基本出发点，甚至常常作为标准配置的基本数据结构以硬件形式直接实现。

    在信息处理领域，无论PostScript或者Java，其实时运行环境都是基于栈结构的虚拟机；网络浏览器多会将用户最近访问过的地址组织为一个栈从而实现前进后退；类似地，主流的文本编辑器也大都支持编辑操作的历史记录功能，用户的编辑操作被依次记录在一个栈中。

    在需要公平且经济地对各种自然或社会资源做管理或分配的场合，无论是调度银行和医院的服务窗口，还是管理轮耕的田地和轮伐的森林，队列都可大显身手。甚至计算机及其网络自身内部的各种计算资源，无论是多进程共享的CPU时间，还是多用户共享的打印机，也都需要借助队列结构实现合理和优化的分配。

栈和队列可视作向量与列表的特例，因此C++的继承与封装机制在此可以大显身手。本章的重点将不再拘泥于对数据结构
内部实现机制的展示，并转而更多地从其外部特性出发，结合若干典型的实际问题介绍栈与队列的具体应用。

## 栈

### ADT接口

操作接口       功 能
size()      报告栈的规模
empty()     判断栈是否为空
push(e)     将e插至栈顶
pop()       删除栈顶对象
top()       引用栈顶对象

#### 入栈和出栈

栈（stack）是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故也可定义首、末元素。不过，尽管栈结构也支持对象的插入和删除操作，但其操作的范围仅限于栈的某一特定端。也就是说，若约定新的元素只能从某一端插入其中，则反过来也只能从这一端删除已有的元素。禁止操作的另一端，称作盲端。栈中可操作的一端更多地称作栈顶（stack top），而另一无法直接操作的盲端则更多地称作栈底（stack bottom）。

除了引用栈顶的top()等操作外，最常用的插入与删除操作分别称作入栈（push）和出栈（pop）。

#### 后进先出（LIFO）

栈中元素接受操作的次序必然始终遵循所谓“后进先出”（last-in-first-out, LIFO）的规律：更晚（早）出栈的元素，应为更早（晚）入栈者；反之，更晚（早）入栈者应更早（晚）出栈。

### Stack模板类

既然栈可视作序列的特例，故只要将栈作为向量的派生类，即可利用C++的继承机制，基于向量模板类实现栈结构。当然，这里需要按照栈的习惯，对各接口重新命名。

既然栈操作都限制于向量的末端，参与操作的元素没有任何后继，以上栈接口的时间复杂度均为常数。
套用以上思路，也可直接基于List模板类派生出Stack类。

## 栈与递归

递归算法所需的空间量，主要决定于最大递归深度。操作系统具体是如何实现函数（递归）调用的？如何记录调用与被调用函数（递归）实例之间的关系？如何实现函数（递归）调用的返回？又是如何维护同时活跃的所有函数（递归）实例的？所有这些问题的答案，都可归结于栈。

### 函数调用栈

在Windows等大部分操作系统中，每个运行中的二进制程序都配有一个调用栈（call stack）或执行栈（execution stack）。借助调用栈可以跟踪属于同一程序的所有函数，记录它们之间的相互调用关系，并保证在每一调用实例执行完毕之后，可以准确地返回。

#### 函数调用

调用栈的基本单位是帧（frame）。每次发生函数调用时会产生一个帧，帧里面保存了跳转之前的地址，也就是被调用函数用来返回的地址，以及原函数的局部变量，传入调用函数的参数等，然后将帧入栈。若该函数返回之前又发生了调用，进行相同的处理。直到函数一个个完成，对应的帧一个个弹出。运行控制权将被交还给返回到的上层调用函数，并按照该帧中记录的返回地址确定在二进制程序中继续执行的位置。

在任一时刻，调用栈中的各帧，依次对应于那些尚未返回的调用实例，亦即当时的活跃函数实例（active function instance）。特别地，位于栈底的那帧必然对应于入口主函数main()，若它从调用栈中弹出，则意味着整个程序的运行结束，此后控制权将交还给操作系统。仿照递归跟踪法，程序执行过程出现过的函数实例及其调用关系，也可构成一棵树，称作该程序的运行树。任一时刻的所有活跃函数实例，在调用栈中自底到顶，对应于运行树中从根节点到最新活跃函数实例的一条调用路径。此外，调用栈中各帧还需存放其它内容。比如，因各帧规模不一，它们还需记录前一帧的起始地址，以保证其出栈之后前一帧能正确地恢复。

#### 递归

作为函数调用的特殊形式，递归也可借助上述调用栈得以实现。比如对应于一个函数funcB()的自我调用，也会新压入一帧。可见，同一函数可能同时拥有多个实例，并在调用栈中各自占有一帧。这些帧的结构完全相同，但其中同名的参数或变量，都是独立的副本。

### 避免递归

在进行递归调用时，系统在后台隐式地维护调用栈的过程中，难以区分哪些参数和变量是对计算过程有实质作用的，更无法以通用的方式对它们进行优化，因此不得不将描述调用现场的所有参数和变量悉数入栈。再加上每一帧都必须保存的执行返回地址以及前一帧起始位置，往往导致程序的空间效率不高甚至极低；同时，隐式的入栈和出栈操作也会令实际的运行时间增加不少。

在追求更高效率的场合，应尽可能地避免递归，尤其是过度的递归。此前已经介绍过相应的方法和技巧。例如将尾递归转换为等效的迭代形式；中采用动态规划策略，将Fibonacci数算法中的二分递归改为线性递归，直至完全消除递归。

既然递归本身就是操作系统隐式地维护一个调用栈而实现的，自然也可以通过显式地模拟调用栈的运转过程，实现等效的算法功能。采用这一方式，程序员可以精细地裁剪栈中各帧的内容，从而尽可能降低空间复杂度的常系数。尽管算法原递归版本的高度概括性和简洁性将大打折扣，但毕竟在空间效率方面可以获得足够的补偿。

## 栈的典型应用

### 逆序输出

在栈所擅长解决的典型问题中，有一类具有以下共同特征：
首先，虽有明确的算法，但其解答却以线性序列的形式给出；其次，无论是递归还是迭代实现，该序列都是依逆序计算输出的；最后，输入和输出规模不确定，难以事先确定盛放输出数据的容器大小。因其特有的“后进先出”特性及其在容量方面的自适应性，使用栈来解决此类问题可谓恰到好处。

#### 进制转换

- 问题

任给十进制整数n，将其转换为r进制的表示形式。

- 分析

比如r=8时，12345(10) = 30071(8)，一般的，r进制转10进制的方法是，n=（dm…d2d1d0）（r）=dm*r^m+…+d2*r^2+d1*r^1+d0*r^0。反过来，10进制转r进制，k（10）%r，第一个与出来的数就是r进制的最低位，余数继续和r相于，获得r进制的下一位，直到余数为0。可见，该算法的输出的确为一个长度不定的逆序线性序列。

- 实现逻辑

尽管新进制下的各数位须按由低到高次序逐位算出，但只要引入一个栈并将算得的数位依次入栈，则在计算结束后只需通过反复的出栈操作即可由高到低地将其顺序输出。将一个十进制数n于新的进制r相于，结果入栈，余数进入递归，重复操作。最后栈中存放的就是转换后的r进制数的由低到高位。然后依次出栈即可。

- 代码

