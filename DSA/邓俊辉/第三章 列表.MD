# 列 表

## 从向量到列表

向量作为一种线性序列，是各数据项的物理存放位置与逻辑次序完全对应，因此可以“循秩访问”。列表同为线性序列结构，也就是在逻辑上内部元素前后相连，但是不同之处是列表的各个元素的物理地址可以任意。

如何在物理地址任意的情况下保持元素逻辑相连，便要引入一种索引关系，这种关系需要指明逻辑上互为前驱和后继的元素的位置。故列表元素是“循位置访问”。这种内部存储方式的差异可以让列表能解决一些向量无法解决的问题。

### 从静态到动态

数据结构支持的操作无非静态和动态两类：前者仅从中获取信息，后者则会修改数据结构的局部甚至整体。也就是读和写。
向量中的size()和get()等静态操作均可在常数时间内完成，而insert()和remove()等动态操作却都可能需要线性时间。究其原因，在于“各元素物理地址连续”的约定，此即所谓的“**静态存储**”策略。

静态存储策略换来了常数时间的读取速度，但是为了维持静态，修改操作后必须的调整开销过大，有时甚至局部的修改可能引起大范围甚至整个数据结构的调整。

列表（list）结构尽管也要求各元素在逻辑上具有线性次序，但对其物理地址却未作任何限制，此即所谓“**动态存储**”策略。在其生命期内，此类数据结构将随着内部数据的需要，相应地分配或回收局部的数据空间。如此，元素之间的逻辑关系得以延续，却不必与其物理次序相关。作为代价，此类结构将通过指针或引用等机制实现所谓的“一种索引关系”，来确定各元素的实际物理地址。

#### 链表

链表（linked list）就是一种典型的动态存储结构。其中的数据，分散为一系列称作节点（node）的独立单位，节点之间通过指针相互索引和访问。为了引入新节点或删除原有节点，只需在局部调整相关节点之间的指针。这就意味着，采用动态存储策略，至少可以大大降低动态操作的成本。

### 由秩到位置

动态策略的缺点也十分明显，失去常数级的静态操作效率。

以链表和访问指定元素为例，尽管链表依然是逻辑上顺序相连，甚至每个元素依然指定唯一的秩，但若想访问某个秩对应的元素，只能从链表的第一个元素开始，依次寻找相连的下一个元素，经过r步迭代后才能确定目标元素的物理存储位置。这意味着列表的静态操作和秩的大小正相关，平均而言需要O(n)时间。
对数据结构的访问方式，应与其存储策略相一致。既然继续延用循秩访问的方式已非上策，就应更多地习惯于通过位置，来指代并访问动态存储结构中的数据元素。基于此类结构设计算法时，应更多地借助逻辑上相邻元素之间的位置索引，以实现对目标元素的快速定位和访问，并进而提高算法的整体效率。

### 列表定义

列表是由具有线性逻辑次序的一组元素构成的集合：
L = { a_0, a_1, ..., a_n-1 }
列表是链表结构的一般化推广，其中的元素称作节点（node），分别由特定的位置或链接指代。与向量一样，在元素之间，也可定义前驱、直接前驱，以及后继、直接后继等关系；相对于任意元素，也有定义对应的前缀、后缀等子集。

## 列表的节点与列表接口

### 列表节点

- 节点的ADT接口说明

data()          当前节点所存数据对象
pred()          当前节点前驱节点的位置
succ()          当前节点后继节点的位置
insertAsPred(e) 插入前驱节点，存入被引用对象e，返回新节点位置
insertAsSucc(e) 插入后继节点，存入被引用对象e，返回新节点位置

- ListNode模板类（节点模板类）

每个节点都存有数据对象data。为保证叙述简洁，在不致歧义的前提下不再区分节点及其对应的data对象。
此外，每个节点还设有指针pred和succ，分别指向其前驱和后继。
为了创建一个列表节点对象，只需根据所提供的参数，分别设置节点内部的各个变量。其中前驱、后继节点的位置指针若未予指定，则默认取作NULL。

- 代码

/DSA/ListNode.h

### 列表接口

#### 列表接口说明

size()              报告列表当前的规模(节点总数)
first()、last()     返回首、末节点的位置
insertAsFirst(e)
insertAsLast(e)     将e当做作首、末节点插入
insertA(p, e)
insertB(p, e)       将e当作节点p的直接后继、前驱插入
    remove(p)       删除位置p处的节点，返回其数值
 disordered()       判断所有节点是否已按非降序排列
       sort()       调整各节点的位置，使之按非降序排列
      find(e)       查找目标元素e，失败时返回NULL
    search(e)       查找目标元素e，返回不大于e且秩最大的节点（有序列表）
deduplicate()       剔除重复节点
   uniquify()       剔除重复节点（有序列表）
   traverse()       遍历并统一处理所有节点，处理方法由函数对象指定

对于以上说明中在插入和删除中出现的p，默认其位置已经获得。
与向量一样，有序列表的唯一化，比无序列表效率更高。然而，由于只能通过位置指针以局部移动的方式访问节点，尽管有序列表中节点在逻辑上始终按照大小次序排列，其查找操作的效率并没有实质改进。

#### List模板类

列表结构的实现方式与第2章的向量结构颇为相似:通过模板参数T指定列表元素的类型;
在内部设置私有变量以记录当前规模等状态信息;基于多种排序算法提供统一的sort()接口，以将列表转化为有序列表。

- 代码

/DSA/List.cpp

## 列表的实现

### 头尾节点（哨兵节点）

- 定义

List对象内部结构犹如一串块链，□-□-□，一个方块代表一个节点，其中私有的头(header)和尾(trailer)节点始终存在，但对外不可见。外部可见的节点如何存在，则第一个成为首节点(first node)，最后一个称为末节点(last node)。显然，首节点的直接前驱就是头节点。这类外部不可见的节点称为哨兵节点，被等效的视作NULL。

- 作用

设置哨兵节点后，对于一个List的任何外部可见的节点，在内部都必然存在前去和后继，这将简化一些算法的描述。比如first()、last()（返回首、末节点的位置）操作，只需直接返回header->succ或trailer->pred。

更重要的，哨兵节点的存在使得不必再专门处理各种边界退化的情况，从而避免类似边界错误。

### List类默认构造方法

创建一个List对象时，需要在内部创建一对头尾节点，并设置好指针，构成一个双向链表。

- 代码

/DSA/List.cpp/List<T>::init()

### 由秩到位置的转换

偶尔可能需要通过秩定位列表，因此可以先重载一下“[]”运算符，提供一个转换接口。

而实际操作中，依然是必须要从首节点出发，向后寻找r次，只要提供的r合法，显然可以找到目标节点，同样显然时间效率为o(r+1)~o(n)。

- 代码

/DSA/List.cpp/List<T>::operator[]

### 查找

查找分为区间查找和全部查找，全部查找作为特例只需直接调用区间查找算法。区间查找时，传入目标数据e和查找范围终止位置的节点指针p，和向前的查找范围n，从p开始依次向前查找，要么命中返回，要么越界返回，复杂度明显为o(n)。

- 代码

/DSA/List.cpp/List<T>::find()

### 插入

### 基于复制的构造

### 删除

### 析构

### 唯一化

### 遍历

## 有序列表

### 唯一化（有序列表）

### 查找（有序列表）

## 排序器

### 插入排序

### 选择排序

### 归并排序
