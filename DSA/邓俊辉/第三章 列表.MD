# 列 表

## 从向量到列表

向量作为一种线性序列，是各数据项的物理存放位置与逻辑次序完全对应，因此可以“循秩访问”。列表同为线性序列结构，也就是在逻辑上内部元素前后相连，但是不同之处是列表的各个元素的物理地址可以任意。

如何在物理地址任意的情况下保持元素逻辑相连，便要引入一种索引关系，这种关系需要指明逻辑上互为前驱和后继的元素的位置。故列表元素是“循位置访问”。这种内部存储方式的差异可以让列表能解决一些向量无法解决的问题。

### 从静态到动态

数据结构支持的操作无非静态和动态两类：前者仅从中获取信息，后者则会修改数据结构的局部甚至整体。也就是读和写。
向量中的size()和get()等静态操作均可在常数时间内完成，而insert()和remove()等动态操作却都可能需要线性时间。究其原因，在于“各元素物理地址连续”的约定，此即所谓的“**静态存储**”策略。

静态存储策略换来了常数时间的读取速度，但是为了维持静态，修改操作后必须的调整开销过大，有时甚至局部的修改可能引起大范围甚至整个数据结构的调整。

列表（list）结构尽管也要求各元素在逻辑上具有线性次序，但对其物理地址却未作任何限制，此即所谓“**动态存储**”策略。在其生命期内，此类数据结构将随着内部数据的需要，相应地分配或回收局部的数据空间。如此，元素之间的逻辑关系得以延续，却不必与其物理次序相关。作为代价，此类结构将通过指针或引用等机制实现所谓的“一种索引关系”，来确定各元素的实际物理地址。

#### 链表

链表（linked list）就是一种典型的动态存储结构。其中的数据，分散为一系列称作节点（node）的独立单位，节点之间通过指针相互索引和访问。为了引入新节点或删除原有节点，只需在局部调整相关节点之间的指针。这就意味着，采用动态存储策略，至少可以大大降低动态操作的成本。

### 由秩到位置

动态策略的缺点也十分明显，失去常数级的静态操作效率。

以链表和访问指定元素为例，尽管链表依然是逻辑上顺序相连，甚至每个元素依然指定唯一的秩，但若想访问某个秩对应的元素，只能从链表的第一个元素开始，依次寻找相连的下一个元素，经过r步迭代后才能确定目标元素的物理存储位置。这意味着列表的静态操作和秩的大小正相关，平均而言需要O(n)时间。
对数据结构的访问方式，应与其存储策略相一致。既然继续延用循秩访问的方式已非上策，就应更多地习惯于通过位置，来指代并访问动态存储结构中的数据元素。基于此类结构设计算法时，应更多地借助逻辑上相邻元素之间的位置索引，以实现对目标元素的快速定位和访问，并进而提高算法的整体效率。

### 列表

列表是由具有线性逻辑次序的一组元素构成的集合：
L = { a_0, a_1, ..., a_n-1 }
列表是链表结构的一般化推广，其中的元素称作节点（node），分别由特定的位置或链接指代。与向量一样，在元素之间，也可定义前驱、直接前驱，以及后继、直接后继等关系；相对于任意元素，也有定义对应的前缀、后缀等子集。

## 列表的节点与接口

### 列表节点

#### 节点的ADT接口说明

data()          当前节点所存数据对象
pred()          当前节点前驱节点的位置
succ()          当前节点后继节点的位置
insertAsPred(e) 插入前驱节点，存入被引用对象e，返回新节点位置
insertAsSucc(e) 插入后继节点，存入被引用对象e，返回新节点位置

#### ListNode模板类

每个节点都存有数据对象data。为保证叙述简洁，在不致歧义的前提下不再区分节点及其对应的data对象。此外，每个节点还设有指针pred和succ，分别指向其前驱和后继。为了创建一个列表节点对象，只需根据所提供的参数，分别设置节点内部的各个变量。其中前驱、后继节点的位置指针若未予指定，则默认取作NULL。

- 代码

/DSA/ListNode.cpp
