# 向 量

数据结构是数据项的结构化集合，其结构性表现为定义于数据项之间的某种逻辑次序。根据这种逻辑次序的复杂程度，大致可以将各种数据结构划分为*线性结构、半线性结构与非线性结构*三大类。
在线性结构中，最为基本的线性结构统称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可进一步地将序列区分为向量（vector）和列表（list）。
在向量中，所有数据项的物理存放位置与其逻辑次序完全吻合，此时的逻辑次序也称作秩
（rank）；而在列表中，逻辑上相邻的数据项在物理上未必相邻，而是采用间接定址的方式通过封装后的位置（position）相互引用。

## 从数组到向量

### 数组

一组相关元素各元素之间具有一个线性次序，则可将它们存放于起始于地址A、物理位置连续的一段存储空间，并统称作数组（array），通常以A作为该数组的标识。数组A[]中的每一元素都唯一对应于某一下标编号，通常从0开始编号。

    其中，对于任何0<=i< j < n，A[i]都是A[j]的*前驱*（predecessor），A[j]都是A[i]的*后继*（successor）。
    特别地，对于任何i>=1，A[i-1]称作A[i]的*直接前驱*（immediate predecessor）;对于任何i <= n-2，A[i+1]称作A[i]的*直接后继*（immediate successor）。
    任一元素的所有前驱构成其*前缀*（prefix），所有后继构成其*后缀*（suffix）。

采用这一编号规范使得我们可以直接访问到任意元素，“直接”是指这些对某以元素的增删改查的操作可以在常数时间内完成，只要从首地址A出发，根据元素编号可以经过简单的乘法和加法运算直接计算出元素对应物理地址。
因其中元素的物理地址与其下标之间满足这种线性关系，故亦称作线性数组（linear array）。

### 向量

对数组这一具体数据结构进行抽象和推广，向量（vector）就是线性数组的一种抽象与泛化，由具有线性次序的一组元素构成的集合V = {v0,v1,...,vn-1}，其中的元素分别由秩相互区分。(若元素e的前驱元素共计r个，则其秩就是r)

经如此抽象之后，不再限定同一向量中的各元素都属于同一基本类型，各元素也不见得同时具有某一数值属性，故而并不保证它们之间能够相互比较大小。

## 接口

### ADT接口

作为一种抽象数据类型，向量对象应支持如下操作接口。

操作接口    功能                 适用对象
size() 报告向量当前规模（元素总数） 向量
get(r) 获取秩为r的元素 向量
put(r, e) 用e替换秩为r元素的数值 向量
insert(r, e) e作为秩为r元素插入，原后继元素依次后移 向量
remove(r) 删除秩为r的元素，返回该元素中原存放的对象 向量
disordered() 判断所有元素是否已按非降序排列 向量
sort() 调整各元素的位置，使之按非降序排列 向量
find(e) 查找等于e，且秩最大的元素 向量
search(e) 查找目标元素e，返回不大于e且秩最大的元素 有序向量
deduplicate() 剔除重复元素 向量
uniquify() 剔除重复元素 有序向量
traverse() 遍历向量并统一处理所有元素，处理斱方法由函数对象指定 向量

### Vector模板类

/DSA/Vector.cpp

#### 函数模板

#### 类模板

#### 重载运算符

为什么要重载赋值运算符：对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。
运算符重载函数本质就是将一个运算符与一个类内函数做映射，运算符不再执行他原始的程序，而执行你重载那个函数。重载，不过是一个函数名比较特殊的一个函数，函数名规则是：operator接运算符

由于向量内部含有动态分配的空间，默认的运算符"="不足以支持向量之间的直接赋值。例如，6.3节将以二维向量形式实现图邻接表，其主向量中的每一元素本身都是一维向量，故通过默认赋值运算符，并不能复制向量内部的数据区。为适应此类赋值操作的需求，重载向量的赋值运算符。
代码：/DSA/Vector.cpp/Vector< T >::operator=

#### 构造函数

#### 析构函数

### 空间管理

装填因子：向量实际规模与其内部数组容量的比值（即_size/_capacity），亦称作装填因子（load factor），它是衡量空间利用率的重要指标。
如何才能保证向量的装填因子既不致于超过1，也不致于太接近于0？静态空间显然无法实现，需要改用动态空间管理策略。其中一种有效的方法，即使用所谓的可扩充向量。

#### 可扩充向量

策略：如果数组空间满了，则给她换一个更大的新空间
    为何不直接在后面追加新空间，因为要求物理地址的关系和逻辑地址的关系一致，也就是物理地址也必须相连，显然无法保证在任何时刻已用数组后面都还有足够的空白空间可用来扩容

代码：/DSA/Vector.cpp/Vector< T >::expand()
    注意：由于数组扩容时是新开辟的空间，地址由系统分配，与原数组没有关系，原地址被释放。如果程序是直接操作的数组，就会导致其他地方对数组的引用都变成野指针。现在封装在向量里，向量指针不会变，开辟新空间时新空间地址会直接指向原向量指针，因此避免了野指针的情况发生。

要解决的问题：扩多少
下一节进行分析

#### 分摊分析

可扩容向量的代价是————每次扩容，元素的搬迁都需要花费额外的时间。
对于规模为n的向量，看似每次扩容，都要消耗o(n)的时间，但是由于不可能出现连续扩容的情况，即随着向量规模的不断扩大，在执行插入操作之前需要进行扩容的概率，也将迅速降低。所以不适用于用平均复杂度分析，因此采用分摊分析。
不妨考查对可扩充向量的足够多次连续操作，并将其间所消耗的时间，分摊至所有的操作。如此分摊平均至单次操作的时间成本，称作分摊运行时间（amortized running time）。
以可扩充向量为例，可以考查对该结构的连续n次（查询、插入或删除等）操作，将所有操作中用于内部数组扩容的时间累计起来，然后除以n。只要n足够大，这一平均时间就是用于扩容处理的分摊时间成本。即便排除查询和删除操作而仅考查插入操作，在可扩充向量单次操作中，用于扩容处理的分摊时间成本也不过O(1)。

#### 其他扩容策略

早期可扩充向量多采用另一策略：一旦有必要，则追加固定数目的单元。实际上，无论采用的固定常数多大，在最坏情况下，此类数组单次操作的分摊时间复杂度都将高达o(n)。

#### 缩容

略

### 常规向量

#### 直接引用元素

由于现在封装成了向量结构，导致无法像数组那样便捷的使用下标访问元素，重新恢复这个功能的方法也很简单，那就是重载操作符“[]”，特别的，由于返回的是对数组元素的引用，因此不仅可以取代get()方法，同样也可以取代set()方法。
代码：/DSA/Vector.cpp/Vector< T >::operator[]

#### 置乱器

基于恢复直接引用，方便的实现置乱算法：
从待置乱区间的末端开始，向前逐一处理元素。对于当前元素V[i-1],先通过随机函数rand在[0,i)之间随机获取一个数字j，然后通过交换函数swap()将当前元素与V [j]互换。经过O(n)步迭代后实现整体的置乱。
代码：/DSA/Vector.cpp/permute()
/DSA/Vector.cpp/Vector< T >::unsort()

#### 判等器与比较器

“判断两个对象是否相等（比对）”与“判断两个对象的相对大小（比较）”都是至关重要的操作，它们直接控制着算法执行的分支方向，因此也是算法的“灵魂”所在。
算法实现的简洁性与通用性，在很大程度上体现于：针对整数等特定数据类型的某种实现，可否推广至可比较或可比对的任何数据类型，而不必关心如何定义以及判定其大小或相等关系。若能如此，我们就可以将比对和比较操作的具体实现剥离出来，直接讨论算法流程本身。
为此，通常可以采用两种方法。其一，将比对操作和比较操作分别封装成通用的判等器和比较器。其二，在定义对应的数据类型时，通过重载"<"和"=="之类的操作符，给出大小和相等关系的具体定义及其判别方法。该书将主要采用后一方式。

在一些复杂的数据结构中，内部元素本身的类型可能就是指向其它对象的指针；对其进行比较所得结果毫无意义。为此，以根据输入是指针还是数值进行重载的方式将这种情况与一般情况予以区分，并且约定在这种情况下，统一按照被指对象的大小做出判断，也就是如果是指针，便取得对应数值传给重新调用的比较函数，使用重载后的数值比较函数进行比较。
代码：代码：/DSA/Vector.cpp/Vector< T >::lt/eq()

#### 无序查找

- 无序向量

Vector::find(e)接口，功能语义为“查找与数据对象e相等的元素”。这暗示着，向量元素可通过相互比对判等。比如通过，元素类型T或为基本类型，或已重载操作符“==”或“!=”等方式实现。
这种只能比较元素是否一样，但是元素之间没有大小之分的向量，称作无序向量（unsorted vector）。

- 实现逻辑

在无序向量中查找任意指定元素e时，因为没有更多的信息可以借助，故在最坏情况下，比如向量中并不包含e时，只有在访遍所有元素之后，才能得出查找结论。因此不妨从后往前一个个比对，要么找到相同元素，要么全部比对后查找失败。这种依次逐个比对的查找方式，称作*顺序查找*（sequential search）。
代码：代码：/DSA/Vector.cpp/Vector< T >::find()

- 复杂度

最坏情况下，查找终止于首元素_elem[lo]，运行时间为O(hi - lo) = O(n)。最好情况下，查找命中于末元素_elem[hi - 1]，仅需O(1)时间。
对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别，故此类算法也称作输入敏感的（input sensitive）算法。
