# 绪论

广义角度

## 广义计算机

一套能完成特定计算功能的机器，比如算盘，尺规等

## 广义算法

计算工具内蕴含的实现计算的原理，由一组基本操作构成。

## 冒泡排序

计算机需要完成的计算相当一部分都是排序工作，下面考察最简单冒泡排序，学习分析思路。

### 1. 局部有序与整体有序

一组序列A[0,n-1]，满足A[i-1]≤A[i]的相邻元素称为顺序的，一个整体有序的序列显然所有相邻元素都有序。同样，不存在逆序的相邻元素的序列也必然整体有序。

### 2. 扫描交换

根据局部有序和整体有序的关系，可以通过不断改善局部有序性实现整体有序。如从后向前依次检查每个元素，一旦发现逆序就交换二者的位置。对于长度n的序列，共需做n-1次比较和不超过n-1次的交换，这一过程称作一趟扫描交换。

    思考：目标是整体有序，跟整体有序有关系的有局部有序，局部有序比整体有序更容易实现。
    即通过目标和一些更容易实现的相关问题的关系，借相关问题间接实现目标。

### 3. 冒泡排序

一趟扫描交换后，大概率并不会整体有序

    仔细分析这个过程：在第一趟中，选定第一个位置，一趟中会遇到大于他的和小于他的，我们依次扫描把遇到的每一个小于他的都和他交换，由此第一个位置时刻保持着在已排序列里元素最小的特性，当排完一趟时，第一个位置便是整个序列中最小的元素。

我们可以发现每一次的交换都会把待排序列中的极值搬到对应的边缘，即最终位置。切实的实现了一个元素的局部有序，因此至多再对序列进行n-1趟扫描交换。直到整体有序。

## 冒泡排序具体实现（版本1A，升序）

整体思路是通过**扫描交换**一次次完成局部有序，从而实现最终整体有序。

首先需要一个**待排序列**，然后需要引入一个参数用来**标记是否存在逆序**，每一趟的扫描交换都会使**问题规模**即待排序列的大小减少一个，然后**扫描交换的循环次数**由是否已经整体有序决定，最后由于是直接修改原序列，所以无需返回排序结果。

导入数据：待排序列，问题规模

返回数据：无

引入参数：sorted

程序过程：

（一趟扫描交换）先假定已经有序，即sorted置true。然后先选中第一个元素，从前向后比较，如果后面的元素小于选中元素，互换位置，时刻保持选中元素是最小元素，如果出现交换，最起码说明在这趟之前存在逆序，于是sorted置false表示还没实现整体有序。

    由于在一趟中选中元素要依次和后面的比较，递增的是被比较元素，因此代码上让i的前一个和递增的i比较。

（循坏趟数）使用一个while循环检测sorted，如果为true，表示整体已经全部有序，已经没有出现逆序，跳出循环，结束程序。

代码地址：DSA/bubblesort.cpp

## 算法

### 定义

基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。

### 算法必备的要素

1. 输入输出
2. 基本操作（属于现代电子计算机所支持的基本操作）
3. 确定性（算法应可描述为由若干语义明确的基本操作组成的指令序列）
4. 可行性（每一基本操作在对应的计算模型中均可兑现）
5. 有穷性（应在执行有限次基本操作之后终止并给出输出）
6. 正确性

        证明算法有穷性和正确性的一个重要技巧，就是从适当的角度审视整个计算过程，并找出其所具有的某种不变性和单调性。其中的单调性通常是指，问题的有效规模会随着算法的推进不断递减。不变性则不仅应在算法初始状态下自然满足，而且应与最终的正确性相呼应——当问题的有效规模缩减到0时，不变性应随即等价于正确性。
        以冒泡排序为例：
        由于冒泡排序每一趟扫描交换总可以确定一个元素的最终位置，且下一次扫描只会操作其他的n-1个元素，待求解问题规模得到缩小，于是冒泡算法的不变性表示为：经过k趟扫描交换后，最大的k个元素必然就位；单调性表示为：经过k趟扫描交换后，待求解问题规模将缩减至n-k。
        特别地，初始状态下k = 0，这两条性质都自然满足。

### 算法效率

1. 可计算性 本书不讨论不可计算的问题
2. 难解性 计算成本过高的问题，也不考虑
3. 需要一种尺度，来衡量一般性问题的算法效率
4. 不同计算环境和算法支持的数据结构不同，效率也不同

### 复杂度度量（渐进复杂度）

  问题规模：算法的效率牵涉甚多，即使只从计算运行速度进行入手依然十分复杂。以排序算法为例，输入序列的规模，初始顺序，大小都影响了计算时间，为建立可靠评估标准，首先考虑其中最关键因素：问题规模。问题规模一般决定计算成本。一般情况问题规模接近的计算成本也接近，问题规模扩大，计算成本也随之上升。
  时间复杂度：因此，首先将算法的效率问题转化为**随着问题规模增大，算法执行时间增长幅度**的问题。
将这个问题表示成一个“输入问题规模，输出时间规模”的函数，称之为算法的时间复杂度，记作T(n)。

#### 大O记号
