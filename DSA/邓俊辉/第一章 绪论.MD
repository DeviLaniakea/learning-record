# 绪论

广义角度

## 广义计算机

一套能完成特定计算功能的机器，比如算盘，尺规等

## 广义算法

计算工具内蕴含的实现计算的原理，由一组基本操作构成。

## 冒泡排序

计算机需要完成的计算相当一部分都是排序工作，下面考察最简单冒泡排序，学习分析思路。

### 1. 局部有序与整体有序

一组序列A[0,n-1]，满足A[i-1]≤A[i]的相邻元素称为顺序的，一个整体有序的序列显然所有相邻元素都有序。同样，不存在逆序的相邻元素的序列也必然整体有序。

### 2. 扫描交换

根据局部有序和整体有序的关系，可以通过不断改善局部有序性实现整体有序。如从后向前依次检查每个元素，一旦发现逆序就交换二者的位置。对于长度n的序列，共需做n-1次比较和不超过n-1次的交换，这一过程称作一趟扫描交换。

    思考：目标是整体有序，跟整体有序有关系的有局部有序，局部有序比整体有序更容易实现。
    即通过目标和一些更容易实现的相关问题的关系，借相关问题间接实现目标。

### 3. 冒泡排序

一趟扫描交换后，大概率并不会整体有序

    仔细分析这个过程：在第一趟中，选定第一个位置，一趟中会遇到大于他的和小于他的，我们依次扫描把遇到的每一个小于他的都和他交换，由此第一个位置时刻保持着在已排序列里元素最小的特性，当排完一趟时，第一个位置便是整个序列中最小的元素。

我们可以发现每一次的交换都会把待排序列中的极值搬到对应的边缘，即最终位置。切实的实现了一个元素的局部有序，因此至多再对序列进行n-1趟扫描交换。直到整体有序。

## 冒泡排序具体实现（版本1A，升序）

整体思路是通过**扫描交换**一次次完成局部有序，从而实现最终整体有序。

首先需要一个**待排序列**，然后需要引入一个参数用来**标记是否存在逆序**，每一趟的扫描交换都会使**问题规模**即待排序列的大小减少一个，然后**扫描交换的循环次数**由是否已经整体有序决定，最后由于是直接修改原序列，所以无需返回排序结果。

导入数据：待排序列，问题规模

返回数据：无

引入参数：sorted

程序过程：

（一趟扫描交换）先假定已经有序，即sorted置true。然后先选中第一个元素，从前向后比较，如果后面的元素小于选中元素，互换位置，时刻保持选中元素是最小元素，如果出现交换，最起码说明在这趟之前存在逆序，于是sorted置false表示还没实现整体有序。

    由于在一趟中选中元素要依次和后面的比较，递增的是被比较元素，因此代码上让i的前一个和递增的i比较。

（循坏趟数）使用一个while循环检测sorted，如果为true，表示整体已经全部有序，已经没有出现逆序，跳出循环，结束程序。

代码地址：DSA/bubblesort.cpp

## 算法

### 定义

基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。

### 算法必备的要素

1. 输入输出
2. 基本操作（属于现代电子计算机所支持的基本操作）
3. 确定性（算法应可描述为由若干语义明确的基本操作组成的指令序列）
4. 可行性（每一基本操作在对应的计算模型中均可兑现）
5. 有穷性（应在执行有限次基本操作之后终止并给出输出）
6. 正确性

        证明算法有穷性和正确性的一个重要技巧，就是从适当的角度审视整个计算过程，并找出其所具有的某种不变性和单调性。其中的单调性通常是指，问题的有效规模会随着算法的推进不断递减。不变性则不仅应在算法初始状态下自然满足，而且应与最终的正确性相呼应——当问题的有效规模缩减到0时，不变性应随即等价于正确性。
        以冒泡排序为例：
        由于冒泡排序每一趟扫描交换总可以确定一个元素的最终位置，且下一次扫描只会操作其他的n-1个元素，待求解问题规模得到缩小，于是冒泡算法的不变性表示为：经过k趟扫描交换后，最大的k个元素必然就位；单调性表示为：经过k趟扫描交换后，待求解问题规模将缩减至n-k。
        特别地，初始状态下k = 0，这两条性质都自然满足。

### 算法效率

1. 可计算性 本书不讨论不可计算的问题
2. 难解性 计算成本过高的问题，也不考虑
3. 需要一种尺度，来衡量一般性问题的算法效率
4. 不同计算环境和算法支持的数据结构不同，效率也不同

### 复杂度度量（渐进复杂度）

  问题规模：算法的效率牵涉甚多，即使只从计算运行速度进行入手依然十分复杂。以排序算法为例，输入序列的规模，初始顺序，大小都影响了计算时间，为建立可靠评估标准，首先考虑其中最关键因素：问题规模。问题规模一般决定计算成本。一般情况问题规模接近的计算成本也接近，问题规模扩大，计算成本也随之上升。
  时间复杂度：因此，首先将算法的效率问题转化为**随着问题规模增大，算法执行时间增长幅度**的问题。
将这个问题表示成一个“输入问题规模，输出时间规模”的函数，称之为算法的时间复杂度，记作T(n)。

然而事实上规模相同的输入通常也都会有多个，假设一个排序问题，规模为n的序列就有n！种，有的需要交换次数多，有的次数少，显然他们的所需时间并不会相同。因此单纯的T(n)的度量方法并不明确，为此再次做出简化：即从保守估计的角度出发,**在规模为n的所有输入中选择执行时间最长者作为T(n),并以T(n)度量该算法的时间复杂度。**

至此,对于同一问题的两个算法A和B,通过比较其时间复杂度TA(n)和TB(n),即可评价二者对于**同一输入规模n**（忽略小规模问题）的计算效率高低。
在处理更大规模的问题时,效率的些许差异都将对实际执行效果产生巨大的影响。这种着眼长远、更为注重时间复杂度的总体变化趋势和增长速度的策略与方法,即所谓的渐进分析(asymptotic analysis)。

#### 大O记号

针对足够大的输入规模n,简化后的算法执行时间T(n)的渐进增长速度,具体应如何度量和评价?
首先关注T(n)的渐进上界。为此引入所谓“大O记号”。

具体地,若存在正的常数c和函数f(n),使得对任何n >> 2都有 *T(n) <= c∙f(n)* 则可认为在n足够大之后,f(n)给出了T(n)增长速度的一个渐进上界。此时,记之为:**T(n) = O(f(n))**

    两条性质：
    在大O记号的意义下,函数各项正的常系数可以忽略并等同于1。（有O(f(n)) = O(c∙f(n))）
    多项式中的低次项均可忽略,只需保留最高次项。（有O(n^a+n^b) = O(n^a),(a>b)）
    可以看出,大O记号的这些性质的确体现了对函数总体渐进增长趋势的关注和刻画。

#### 基本操作

那么如何计算出一个算法的具体的T(n)，直接在实际环境中测具体时间确实可以，但是变量太多，不同算法测出的数据难以相互比较，因此一种自然且可行的解决办法是,将时间复杂度理解为算法中各条指令的执行时间之和。即***将T(n)定义为算法所执行基本操作的总次数***。也就是说,T(n)决定于组成算法的所有语句*各自的执行次数*,以及其中所含*基本操作的数目*。

    冒泡排序1A为例：有while和for两个循环，for循环每轮扫描比较n-1次，至多交换n-1次，比较和交换都是基本操作，因此至多每轮2(n-1)次操作，while循环至多执行n-1次，因此所有基本操作至多执行2(n-1)^2次，根据最终对T(n)的定义，即T(n) = O(2(n-1)^2)，根据大O记号的性质，可进一步简化和整理为：
    T(n) = O(2n^2-4n+2) = O(2n^2) = O(n^2)

大Ω记号最好情况
    T(n) >= c∙g(n)   记作T(n) = Ω(g(n))
和大Ⓗ记号平均复杂度
    c1∙h(n) <= T(n) <= c2∙h(n)  记作T(n) = Ⓗ(h(n))
不做多记录。

### 复杂度分析

介绍若干典型的复杂度级别，主要的分析方法与技巧。

#### 常数O(1)略

#### 对数O(logn)

后面的暂时跳过，比较着急先复习具体算法。
